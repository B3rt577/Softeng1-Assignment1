'''
Title: EECS 348 Assignment 1
Description: CEO Email prioritization program
Input(s): Assignment1_Test_Files.txt
Output(s): Next email and number of unread emails
All collaborators: Geeks for geeks, ChatGPT, Gemini
Author's name: Edbert Jensen
Creation Date: 8/22/2025
'''

'''
Sources:
- https://www.geeksforgeeks.org/dsa/introduction-to-max-heap-data-structure/

'''
import os
import re

class MaxHeap:
    def __init__(self):
        self.arr = []       # initialize an empty list when MaxHeap object is created
    
    # i should just be a variable that is the position or index the newly inserted node.
    # this fix was with the help of chatGPT. I initially had i as a parameter of MaxHeap and realized that i was suppose to be a temp variable.
    def heapify_up(self, i):
        # the definition of the parent property of Binary Heaps is (index - 1) floor division by 2
        parent = (i - 1) // 2   

        # A condition that checks if the parent is positie and whatever index i is bigger than the parent value
        if parent >= 0 and self.arr[i] > self.arr[parent]:       
            self.arr[i], self.arr[parent] = self.arr[parent], self.arr[i]
        
        # Recursively heapify the parent node
            self.heapify_up(parent)
    
    # i should be the current index 
    def heapify_down(self, i):
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        # condition to fulfill: left child should be lesser than the size of the array and it should be larger than its parent
        if ( left < len(self.arr) ) and ( self.arr[left] > self.arr[largest] ):
        # swap the largest index to be the left index
            largest = left
        
        # 
        if ( right < len(self.arr) ) and ( self.arr[left] > self.arr[largest] ):
            largest = right
        
        if (largest != i):
            self.arr[i],self.arr[largest]=self.arr[largest],self.arr[i]

            #Recursively heapify the affected sub-tree
            self.heapify_down( largest )

    def insertNode(self,key):
        # Insert element to the list
        self.arr.append(key)
        
        # Heapify the new node following a Bottom-up approach
        self.heapify_up( len(self.arr) - 1 )   

    def deleteRoot(self):
        arr_len = len(self.arr)

        lastElement = self.arr[arr_len-1]

        self.arr[0] = lastElement

        arr_len = arr_len - 1   

        self.heapify_down(0)

    def peek(self):
        return self.arr[0] if self.arr else None
    
'''
Sources: 
- https://www.geeksforgeeks.org/dsa/priority-queue-set-1-introduction/
- 

'''
# Priority Queue: a type of queue that arranges based on a priority values
class PriorityQueue:
    def __init__(self):
        self.heap = MaxHeap()

    # a method to insert a key to the Binary MaxHeap
    def enqueue(self, key):
        # insert a new element to the Queue
        self.heap.insertNode(key)
    
    def dequeue(self):
        # return the highest priority element which is the root of a Binary Max Heap and heapify down the Binary Max Heap
        deletedNode = self.heap.peek()
        self.heap.deleteRoot()
        return deletedNode

# Driver class
class Driver:
    def __init__(self):
        self.queue = PriorityQueue()

    def readFile(self, fileName):
        try:
            with open(fileName, "r", encoding="utf-8") as f: 
                lines = f.readlines()
            return lines
        except FileNotFoundError:
            print(f"Error: The file '{fileName}' was not found.")
            return None # Return None to indicate failure
         
    # load file contents and parse accordingly
    def loadAndParse(self, fileContents):
        # check if file contents are there 
        # generated by Gemini.
        if fileContents is None:
            print("Cannot process file because it could not be read.")
            return
        
        # for-loop to access singular content lines when iterating
        for content in fileContents:
            # remove newline in the content
            cleanedLine = content.strip()
            if not cleanedLine:  # Skip empty lines
                continue
            # split the space to access commands
            parts = cleanedLine.split(' ',1) 
            # take the first element of parts as the command
            command = parts[0]

            # check commands 
            if command == "EMAIL":
                if len(parts) < 2:
                    print(f"Skipping malformed EMAIL line (no arguments): {cleanedLine}")
                    continue                    
                # when split is used in a list, it will not make another list inside the list
                details = parts[1].split(',')

                sgDetails = tuple(details)
                match sgDetails[0]:
                     case "Boss":

                        pass

            else:
                continue
            print(sgDetails)
            
            # array = list(content)
            # # modify to accept empty strings
            # if array:
            #     match array[0]:
            #         case "EMAIL":
            #             details = list(array[1]) 
            #             print(details)
            #             break
        
    

if __name__ == '__main__':

    defaultboolval = True

    while defaultboolval != False:
        
        test = input("Insert Test file Name: ")
        x = re.findall(".txt", test)
        if x:
            if isinstance(x[0], str) and x[0] == ".txt":
                # all creation of driver object and calls are made here
                driver = Driver()

                contents = driver.readFile(test)

                if contents:
                    driver.loadAndParse(contents)

                defaultboolval = False
        else:
            defaultboolval = True
    

    

    
        