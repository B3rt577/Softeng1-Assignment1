'''
Title: EECS 348 Assignment 1
Description: CEO Email prioritization program
Input(s): Assignment1_Test_Files.txt
Output(s): Next email and number of unread emails
All collaborators: Geeks for geeks, ChatGPT, Gemini
Author's name: Edbert Jensen
Creation Date: 8/22/2025
'''

'''
Sources:
- https://www.geeksforgeeks.org/dsa/introduction-to-max-heap-data-structure/
- https://gemini.google.com/app

'''
import re
from dataclasses import dataclass

# Generated by Gemini
# It's good practice to use a dataclass for structured data
@dataclass(order=True)
class Email:
    priority: int
    # We add a unique sequence number to handle tie-breaks correctly
    sequence: int
    details: tuple

class MaxHeap:
    def __init__(self):
        self.arr = []       # initialize an empty list when MaxHeap object is created
    
    # i should just be a variable that is the position or index the newly inserted node.
    # this fix was with the help of chatGPT. I initially had i as a parameter of MaxHeap and realized that i was suppose to be a temp variable.
    def heapify_up(self, i):
        # the definition of the parent property of Binary Heaps is (index - 1) floor division by 2
        parent = (i - 1) // 2   

        # A condition that checks if the parent is positie and whatever index i is bigger than the parent value
        if parent >= 0 and self.arr[i] > self.arr[parent]:       
            self.arr[i], self.arr[parent] = self.arr[parent], self.arr[i]

            # Recursively heapify the parent node
            self.heapify_up(parent)
    
    # i should be the current index 
    def heapify_down(self, i):
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        # condition to fulfill: left child should be lesser than the size of the array and it should be larger than its parent
        if ( left < len(self.arr) ) and ( self.arr[left] > self.arr[largest] ):
        # swap the largest index to be the left index
            largest = left
        
        # condition to fulfill: right child should be lesser than the size of the array and it should be larger than its parent
        if ( right < len(self.arr) ) and ( self.arr[right] > self.arr[largest] ):
        # swap the largest index to be the right index
            largest = right
        
        # if largest is not the parent index, swap
        if (largest != i):
            # swap
            self.arr[i],self.arr[largest]=self.arr[largest],self.arr[i]

            #Recursively heapify the affected sub-tree
            self.heapify_down( largest )

    def insertNode(self,key):
        # Insert element to the list
        self.arr.append(key)
        
        # Heapify the new node following a Bottom-up approach
        self.heapify_up( len(self.arr) - 1 )   

    def deleteRoot(self):
        # bug: did not actually delete a space in the list
        # Generated by Gemini
        if not self.arr:
            return None
        
        # record root before deletion
        root = self.arr[0]
        # Bug fix: correctly remove the last element (first) and store it
        last_element = self.arr.pop()  # Remove and get the last element

        # If pop is made here and the condition is true, we will 
        # check if the heap is not empty after popping
        if self.arr:
            # Replace root with the last element and pop the last element
            self.arr[0] = last_element
            # Heapify down from the new root
            self.heapify_down(0)

        return root
    
    def peek(self):
        return self.arr[0] if self.arr else None
    
    # use this for printing the current count of how many unread emails ahead 
    def __len__(self):
        return len(self.arr)

    
'''
Sources: 
- https://www.geeksforgeeks.org/dsa/priority-queue-set-1-introduction/
- https://gemini.google.com/app/8547f7768e4b22f6?_gl=1*r5wlt7*_gcl_aw*R0NMLjE3NTU5OTc3ODIuRUFJYUlRb2JDaE1JeW9yTXBhR2lqd01WSzNGX0FCMHNoaEpKRUFBWUFTQUFFZ0xLT1BEX0J3RQ..*_gcl_dc*R0NMLjE3NTU5OTc3ODIuRUFJYUlRb2JDaE1JeW9yTXBhR2lqd01WSzNGX0FCMHNoaEpKRUFBWUFTQUFFZ0xLT1BEX0J3RQ..*_gcl_au*MTI4ODA5ODU5My4xNzU1OTk3Nzgy

'''
# Priority Queue: a type of queue that arranges based on a priority values
class PriorityQueue:
    def __init__(self):
        self.heap = MaxHeap()

    # a method to insert a key to the Binary MaxHeap
    def enqueue(self, key):
        # insert a new element to the Queue
        self.heap.insertNode(key)
    
    def dequeue(self):
        # return the highest priority element which is the root of a Binary Max Heap and heapify down the Binary Max Heap
        self.heap.deleteRoot()
    
    # check 
    def is_empty(self):
        return len(self.heap) == 0

    def peek(self):
        return self.heap.peek()
    
    def get_count(self):
        return len(self.heap)
    
    # --- PRINTER FUNCTION FOR DEBUGGING ---
    # This is the Pythonic way to create a "printer" for an object.
    # When you call print(your_queue_object), this method will be used.
    def __repr__(self):
        if self.is_empty():
            return "PriorityQueue: [ (empty) ]"
        
        # This will show the contents of the heap clearly
        items = [f"(Prio: {email.priority}, To: {email.details[0]})" for email in self.heap.arr]
        return f"PriorityQueue: [\n  " + ",\n  ".join(items) + "\n]"
    

# Driver class
class Driver:
    def __init__(self):
        self.queue = PriorityQueue()
        self.email_sequence = 0 # Counter to ensure FIFO for same-priority emails

    # read file handler
    # it should take a file name as a parameter
    def readFile(self, fileName):
        # try and except block to handle file not found error
        try:
            # open the file in read mode with utf-8 encoding
            with open(fileName, "r", encoding="utf-8") as f: 
                # lines variable holds all the lines in the file in array format
                lines = f.readlines()
            # return for calling function to use
            return lines
        
        # handle file not found error
        except FileNotFoundError:
            print(f"Error: The file '{fileName}' was not found.")
            return None # Return None to indicate failure
         
    # load file contents and parse accordingly
    def loadAndParse(self, fileContents):
        # check if file contents are there 
        # generated by Gemini.
        if fileContents is None:
            print("Cannot process file because it could not be read.")
            return
        
        # for-loop to access singular content lines when iterating
        for content in fileContents:
            # remove newline in the content
            cleanedLine = content.strip()
            if not cleanedLine:  # Skip empty lines
                continue
            # split the space to access commands
            parts = cleanedLine.split(' ',1) 
            # take the first element of parts as the command
            command = parts[0]

            # check what commands are being used
            # enqueue operation should be handled here
            if command == "EMAIL":
                # check if there are arguments after EMAIL
                if len(parts) < 2:
                    print(f"Skipping malformed EMAIL line (no arguments): {cleanedLine}")
                    continue                    
                
                # when split is used in a list, it will not make another list inside the list
                details = parts[1].split(',')
                # make the first element in details as sender
                sender = details[0]

                while len(details) < 3:
                    details.append('')
                # I will use integers from 1-5 , 5 being the highest priority and 1 being the least.
                # try match value sender to all categories 
                priority_val = 1  # Default priority for any other entity
                match sender:
                    case "Boss":
                        priority_val = 5
                    case "Subordinate":
                        priority_val = 4
                    case "Peer":
                        priority_val = 3
                    case "ImportantPerson":
                        priority_val = 2
                    case "OtherPerson":
                        priority_val = 1

                
                # Make email object and put all prior value, sequenece and details inside
                email_data = Email(priority=priority_val, sequence=self.email_sequence, details=tuple(details))
                # enqueue email data to priority queue data structure
                self.queue.enqueue(email_data)
                # order sequence 
                self.email_sequence += 1  # Increment sequence for next email
                
                # --- USING THE PRINTER FOR DEBUGGING ---
                # print(f"ACTION: Added email from {sender}. Queue state:")
                # print(self.queue)
                # print("-" * 20)

            # dequeue operation should be handled here
            elif command == "NEXT":
                if self.queue.is_empty():
                    print("No unread emails.")

                next_email = self.queue.peek()
                
                if next_email:
                    print(f"\nNext email:\n \tSender: {next_email.details[0]}\n \tSubject: {next_email.details[1]}\n \tDate: {next_email.details[2]}")
            
            # display the current count of unread emails
            elif command == "COUNT":
                print(f"\nThere are {self.queue.get_count()} emails to read.")
            
            # function that signals email has been read and dealt with
            elif command == "READ":
                self.queue.dequeue()

            else:
                print(f"Unkown command: {command}")

# main call
if __name__ == '__main__':
    # set a default boolean value to true
    defaultboolval = True
    # keep asking user for a valid .txt file name until they provide one
    while defaultboolval != False:
        
        # ask user for a file name
        test = input("Insert Test file Name (e.g. include.txt): ")
        # use regex to check if the file name ends with .txt
        x = re.findall(".txt", test)
        # if the file name ends with .txt, proceed
        if x:
            # check if the first element in x is a string and if it is equal to .txt
            if isinstance(x[0], str) and x[0] == ".txt":
                # all creation of driver object and calls are made here
                # make a driver object
                driver = Driver()
                
                # read the file
                contents = driver.readFile(test)

                # if contents are there, load and parse
                if contents:
                    # call load and parse method
                    driver.loadAndParse(contents)
                # set the default boolean value to false to exit the while loop
                defaultboolval = False
        # if the file name does not include string ".txt", ask user again for a valid file name
        else:
            print("Invalid input. Please provide a file name ending with .txt")
    

    

    
        